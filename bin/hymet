#!/usr/bin/env python3
"""Unified HYMET command-line interface."""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Sequence


def run_command(cmd: List[str], *, cwd: Optional[Path] = None, env: Optional[dict] = None, dry_run: bool = False) -> None:
    display = " ".join(str(part) for part in cmd)
    location = str(cwd) if cwd else os.getcwd()
    print(f"[hymet] ({location}) $ {display}")
    if dry_run:
        return
    subprocess.run(cmd, cwd=str(cwd) if cwd else None, env=env, check=True)


def add_common_env(args, env: dict) -> None:
    if getattr(args, "cache_root", None):
        env["CACHE_ROOT"] = str(Path(args.cache_root).resolve())
    if getattr(args, "force_download", False):
        env["FORCE_DOWNLOAD"] = "1"
    if getattr(args, "keep_work", False):
        env["KEEP_HYMET_WORK"] = "1"


def command_run(args) -> None:
    repo_root: Path = args.repo_root
    env = os.environ.copy()
    env["ROOT"] = str(repo_root)
    env["INPUT_FASTA"] = str(Path(args.contigs).resolve())
    env["OUTDIR"] = str(Path(args.out).resolve())
    env["THREADS"] = str(args.threads)
    if args.cand_max is not None:
        env["CAND_MAX"] = str(args.cand_max)
    if args.species_dedup:
        env["SPECIES_DEDUP"] = "1"
    if args.assembly_summary_dir:
        env["ASSEMBLY_SUMMARY_DIR"] = str(Path(args.assembly_summary_dir).resolve())
    add_common_env(args, env)
    cmd = [str(repo_root / "run_hymet_cami.sh")]
    run_command(cmd, cwd=repo_root, env=env, dry_run=args.dry_run)


def command_bench(args) -> None:
    bench_root: Path = args.bench_root
    env = os.environ.copy()
    if args.threads is not None:
        env["THREADS"] = str(args.threads)
    add_common_env(args, env)

    cmd = [str(bench_root / "run_all_cami.sh")]
    if args.manifest:
        cmd.extend(["--manifest", str(Path(args.manifest).resolve())])
    if args.tools:
        cmd.extend(["--tools", args.tools])
    if args.max_samples is not None:
        cmd.extend(["--max-samples", str(args.max_samples)])
    if args.no_build:
        cmd.append("--no-build")
    if args.resume:
        cmd.append("--resume")
    if args.extra:
        cmd.extend(args.extra)
    run_command(cmd, cwd=bench_root, env=env, dry_run=args.dry_run)


def command_case(args) -> None:
    case_root: Path = args.case_root
    env = os.environ.copy()
    if args.threads is not None:
        env["THREADS"] = str(args.threads)
    add_common_env(args, env)

    cmd = [str(case_root / "run_case.sh")]
    if args.manifest:
        cmd.extend(["--manifest", str(Path(args.manifest).resolve())])
    if args.out:
        cmd.extend(["--out", str(Path(args.out).resolve())])
    if args.extra:
        cmd.extend(args.extra)
    run_command(cmd, cwd=case_root, env=env, dry_run=args.dry_run)


def command_ablation(args) -> None:
    case_root: Path = args.case_root
    env = os.environ.copy()
    if args.threads is not None:
        env["THREADS"] = str(args.threads)
    add_common_env(args, env)

    cmd = [str(case_root / "run_ablation.sh")]
    if args.sample:
        cmd.extend(["--sample", args.sample])
    if args.taxa:
        cmd.extend(["--taxa", args.taxa])
    if args.levels:
        cmd.extend(["--levels", args.levels])
    if args.seqmap:
        cmd.extend(["--seqmap", str(Path(args.seqmap).resolve())])
    if args.fasta:
        cmd.extend(["--fasta", str(Path(args.fasta).resolve())])
    if args.out:
        cmd.extend(["--out", str(Path(args.out).resolve())])
    if args.extra:
        cmd.extend(args.extra)
    run_command(cmd, cwd=case_root, env=env, dry_run=args.dry_run)


def command_truth_build_zymo(args) -> None:
    case_root: Path = args.case_root
    env = os.environ.copy()
    seqmap = args.seqmap or case_root / "truth" / "zymo_refs" / "seqid2taxid.tsv"
    cmd = [
        "python",
        str(case_root / "truth" / "build_zymo_truth.py"),
        "--contigs",
        str(Path(args.contigs).resolve()),
        "--seqmap",
        str(Path(seqmap).resolve()),
        "--paf",
        str(Path(args.paf).resolve()),
        "--out-contigs",
        str(Path(args.out_contigs).resolve()),
        "--out-profile",
        str(Path(args.out_profile).resolve()),
    ]
    run_command(cmd, cwd=case_root, env=env, dry_run=args.dry_run)


def command_legacy(args) -> None:
    repo_root: Path = args.repo_root
    cmd = ["perl", str(repo_root / "main.pl"), *args.legacy_args]
    run_command(cmd, cwd=repo_root, env=None, dry_run=args.dry_run)


def add_common_arguments(parser: argparse.ArgumentParser) -> None:
    parser.add_argument("--threads", type=int, help="Thread count to pass to HYMET")
    parser.add_argument("--cache-root", help="Override cache root (CACHE_ROOT)")
    parser.add_argument("--force-download", action="store_true", help="Set FORCE_DOWNLOAD=1 for HYMET runs")
    parser.add_argument("--keep-work", action="store_true", help="Set KEEP_HYMET_WORK=1 to retain intermediates")
    parser.add_argument("--dry-run", action="store_true", help="Show commands without executing them")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="HYMET unified command-line interface")
    parser.add_argument(
        "--hymet-root",
        help="Path to the HYMET repository. Defaults to HYMET_ROOT env or auto-discovery.",
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    run_parser = subparsers.add_parser("run", help="Run HYMET on a single sample")
    run_parser.add_argument("--contigs", required=True, help="Input contigs FASTA")
    run_parser.add_argument("--out", required=True, help="Output directory")
    run_parser.add_argument("--cand-max", type=int, help="Maximum Mash candidates (CAND_MAX)")
    run_parser.add_argument("--species-dedup", action="store_true", help="Enable species-level candidate deduplication")
    run_parser.add_argument("--assembly-summary-dir", help="Directory holding assembly_summary files")
    add_common_arguments(run_parser)
    run_parser.set_defaults(func=command_run)

    bench_parser = subparsers.add_parser("bench", help="Run the CAMI benchmark harness")
    bench_parser.add_argument("--manifest", help="Manifest TSV (default bench/cami_manifest.tsv)")
    bench_parser.add_argument("--tools", help="Comma-separated tool list")
    bench_parser.add_argument("--max-samples", type=int, help="Limit number of samples processed")
    bench_parser.add_argument("--no-build", action="store_true", help="Skip database build step")
    bench_parser.add_argument("--resume", action="store_true", help="Resume without clearing runtime log")
    bench_parser.add_argument("extra", nargs=argparse.REMAINDER, help="Extra args forwarded to run_all_cami.sh")
    add_common_arguments(bench_parser)
    bench_parser.set_defaults(func=command_bench)

    case_parser = subparsers.add_parser("case", help="Run the case-study harness")
    case_parser.add_argument("--manifest", help="Manifest TSV (default case/manifest.tsv)")
    case_parser.add_argument("--out", help="Output root directory")
    case_parser.add_argument("extra", nargs=argparse.REMAINDER, help="Extra args forwarded to run_case.sh")
    add_common_arguments(case_parser)
    case_parser.set_defaults(func=command_case)

    ablation_parser = subparsers.add_parser("ablation", help="Run the curated reference ablation workflow")
    ablation_parser.add_argument("--sample", help="Sample ID to ablate")
    ablation_parser.add_argument("--taxa", help="Comma-separated TaxIDs to remove at each level")
    ablation_parser.add_argument("--levels", help="Comma-separated ablation fractions (e.g. 0,0.5,1.0)")
    ablation_parser.add_argument("--seqmap", help="Sequence-to-taxid map")
    ablation_parser.add_argument("--fasta", help="Reference FASTA to ablate")
    ablation_parser.add_argument("--out", help="Output directory for ablation results")
    ablation_parser.add_argument("extra", nargs=argparse.REMAINDER, help="Extra args forwarded to run_ablation.sh")
    add_common_arguments(ablation_parser)
    ablation_parser.set_defaults(func=command_ablation)

    truth_parser = subparsers.add_parser("truth", help="Truth-set utilities")
    truth_sub = truth_parser.add_subparsers(dest="truth_command", required=True)
    truth_zymo = truth_sub.add_parser("build-zymo", help="Build Zymo mock community truth tables")
    truth_zymo.add_argument("--contigs", required=True, help="Input contigs FASTA")
    truth_zymo.add_argument("--paf", required=True, help="PAF alignment against curated references")
    truth_zymo.add_argument("--seqmap", help="SeqIDâ†’TaxID map (default case/truth/zymo_refs/seqid2taxid.tsv)")
    truth_zymo.add_argument("--out-contigs", required=True, help="Output contig truth TSV")
    truth_zymo.add_argument("--out-profile", required=True, help="Output CAMI profile TSV")
    truth_zymo.add_argument("--dry-run", action="store_true", help="Show command without executing it")
    truth_zymo.set_defaults(func=command_truth_build_zymo)

    legacy_parser = subparsers.add_parser("legacy", help="Bridge to legacy entry points (main.pl)")
    legacy_parser.add_argument("legacy_args", nargs=argparse.REMAINDER, help="Arguments passed to main.pl")
    legacy_parser.add_argument("--dry-run", action="store_true", help="Show command without executing it")
    legacy_parser.set_defaults(func=command_legacy)

    return parser


def locate_repo_root(explicit: Optional[str]) -> Path:
    candidates: List[Path] = []
    if explicit:
        candidates.append(Path(explicit))
    env_root = os.environ.get("HYMET_ROOT")
    if env_root:
        candidates.append(Path(env_root))
    script_dir = Path(__file__).resolve().parent
    candidates.append(script_dir)
    candidates.append(script_dir.parent)
    cwd = Path.cwd()
    candidates.append(cwd)
    candidates.extend(cwd.parents)

    seen = set()
    for candidate in candidates:
        if candidate is None:
            continue
        candidate = candidate.resolve()
        if candidate in seen:
            continue
        seen.add(candidate)
        bench_marker = candidate / "bench" / "run_all_cami.sh"
        case_marker = candidate / "case" / "run_case.sh"
        if bench_marker.exists() and case_marker.exists():
            return candidate
    raise SystemExit(
        "Unable to locate HYMET repository root. Set --hymet-root or HYMET_ROOT to the cloned repository path."
    )


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repo_root = locate_repo_root(args.hymet_root)
    args.repo_root = repo_root
    args.bench_root = repo_root / "bench"
    args.case_root = repo_root / "case"
    try:
        args.func(args)
    except subprocess.CalledProcessError as exc:
        return exc.returncode
    return 0


if __name__ == "__main__":
    sys.exit(main())
